---
description: TypeScript type safety rules - no any, no unsafe casting
globs: **/*.{ts,tsx}
alwaysApply: true
---

# TypeScript Standards

## Core Rule

**All code must be type-safe. Never use `any` or unsafe type casting.**

## Type Safety

### ✅ Always Do This

```tsx
// Explicit types for function parameters and returns
const createTask = ({ title, assigneeId }: CreateTaskInput): Task => { ... };

// Use unknown for truly unknown data, then narrow
const parseResponse = (data: unknown): Task => {
  if (!isTask(data)) throw new Error('Invalid task');
  return data;
};

// Type guards for runtime checks
const isTask = (value: unknown): value is Task => {
  return typeof value === 'object' && value !== null && 'id' in value;
};

// Inference where obvious
const tasks = [task1, task2]; // TypeScript infers Task[]
const count = tasks.length;   // TypeScript infers number
```

### ❌ Never Do This

```tsx
// any - disables all type checking
const data: any = fetchData();
function process(input: any) { ... }

// Type assertions to bypass safety
const task = response as Task;           // ❌ Unsafe assertion
const task = response as unknown as Task; // ❌ Double assertion hack
const task = <Task>response;             // ❌ Legacy assertion syntax

// Non-null assertions without checks
const name = user!.name;      // ❌ Might crash
const first = items![0]!.id;  // ❌ Multiple assumptions

// @ts-ignore / @ts-expect-error to hide problems
// @ts-ignore
brokenCode();
```

## Handling External Data

### ✅ Validate and Narrow

```tsx
// API responses - validate with zod
import { z } from 'zod';

const TaskSchema = z.object({
  id: z.string(),
  title: z.string(),
  status: z.enum(['pending', 'completed']),
});

const fetchTask = async (id: string): Promise<Task> => {
  const response = await apiClient.get(`/tasks/${id}`);
  return TaskSchema.parse(response.data); // Throws if invalid
};

// JSON parsing
const parseConfig = (json: string): Config => {
  const parsed: unknown = JSON.parse(json);
  return ConfigSchema.parse(parsed);
};
```

### ❌ Never Trust External Data

```tsx
// Don't cast API responses
const task = (await fetch('/api/task')).json() as Task; // ❌

// Don't assume localStorage shape
const settings = JSON.parse(localStorage.getItem('settings')!) as Settings; // ❌
```

## Generics Over Any

### ✅ Use Generics

```tsx
// Generic function
const first = <T>(items: T[]): T | undefined => items[0];

// Generic component
function List<T>({ items, renderItem }: ListProps<T>) {
  return items.map(renderItem);
}

// Generic hook
function useApiSWR<T>(endpoint: string): SWRResponse<T> { ... }
```

### ❌ Don't Fall Back to Any

```tsx
// ❌ Lazy any usage
const first = (items: any[]): any => items[0];
function List({ items, renderItem }: { items: any[], renderItem: any }) { ... }
```

## Strict Null Checks

### ✅ Handle Null Properly

```tsx
// Optional chaining
const name = user?.profile?.name;

// Nullish coalescing
const displayName = user.name ?? 'Anonymous';

// Early return for null checks
const processUser = (user: User | null) => {
  if (!user) return null;
  // user is now User (narrowed)
  return user.name;
};
```

### ❌ Don't Assume Non-Null

```tsx
// Non-null assertion without check
const name = user!.name; // ❌ Crashes if user is null

// Ignoring possible undefined
const first = items[0].name; // ❌ Crashes if array is empty
```

## Exceptions

The ONLY acceptable uses of type assertions:

```tsx
// 1. Test mocks (in test files only)
const mockFn = vi.fn() as Mock<typeof realFn>;

// 2. DOM refs after null check
const input = inputRef.current;
if (input) {
  (input as HTMLInputElement).focus();
}

// 3. Event targets with type narrowing
const handleChange = (e: Event) => {
  const target = e.target as HTMLInputElement; // After checking it's an input
};
```

## Checklist

Before committing:

- [ ] No `any` types anywhere
- [ ] No unsafe type assertions (`as Type`)
- [ ] No non-null assertions (`!`) without prior checks
- [ ] No `@ts-ignore` or `@ts-expect-error`
- [ ] External data validated with zod
- [ ] Generics used instead of any for reusable code
- [ ] Null/undefined handled with optional chaining or guards
