/**
 * Script to generate TaskTemplateId type from the task templates JSON.
 * Run with: bun run scripts/generate-task-types.ts
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

interface TaskTemplate {
  id: string;
  name: string;
  description: string;
  frequency: string;
  department: string;
}

const TASK_TEMPLATES_PATH = join(
  __dirname,
  '../../../packages/db/prisma/seed/primitives/FrameworkEditorTaskTemplate.json',
);

const OUTPUT_PATH = join(__dirname, '../src/task-mappings.ts');

function generateTaskTypes() {
  // Read the JSON file
  const jsonContent = readFileSync(TASK_TEMPLATES_PATH, 'utf-8');
  const tasks: TaskTemplate[] = JSON.parse(jsonContent);

  // Generate the TypeScript file
  const lines: string[] = [
    '// ============================================================================',
    '// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY',
    '// Generated by: bun run scripts/generate-task-types.ts',
    '// ============================================================================',
    '',
    '/**',
    ' * All available task template IDs that can be used for task mapping.',
    ' * These are derived from the FrameworkEditorTaskTemplate seed data.',
    ' */',
    'export const TASK_TEMPLATE_IDS = [',
  ];

  // Add each task ID as a const
  for (const task of tasks) {
    lines.push(`  '${task.id}', // ${task.name}`);
  }

  lines.push('] as const;');
  lines.push('');
  lines.push('/**');
  lines.push(' * Union type of all valid task template IDs.');
  lines.push(' * Use this for type-safe task mapping in integration checks.');
  lines.push(' */');
  lines.push('export type TaskTemplateId = (typeof TASK_TEMPLATE_IDS)[number];');
  lines.push('');

  // Add a mapping object for easy lookup by name
  lines.push('/**');
  lines.push(' * Mapping of task names to their IDs for easier reference.');
  lines.push(' * Use this when you know the task name but need the ID.');
  lines.push(' */');
  lines.push('export const TASK_TEMPLATES = {');

  for (const task of tasks) {
    // Convert name to a valid JS identifier (camelCase, no special chars)
    const key = task.name
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .split(/\s+/)
      .map((word, i) =>
        i === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase(),
      )
      .join('');

    lines.push(`  /** ${task.name} */`);
    lines.push(`  ${key}: '${task.id}',`);
  }

  lines.push('} as const;');
  lines.push('');

  // Add a reverse mapping for getting task info by ID
  lines.push('/**');
  lines.push(' * Task template metadata for reference.');
  lines.push(' */');
  lines.push('export const TASK_TEMPLATE_INFO: Record<');
  lines.push('  TaskTemplateId,');
  lines.push('  { name: string; description: string; department: string; frequency: string }');
  lines.push('> = {');

  for (const task of tasks) {
    // Escape description for use in template literal
    const escapedDesc = task.description
      .replace(/\\/g, '\\\\')
      .replace(/`/g, '\\`')
      .replace(/\$/g, '\\$')
      .substring(0, 100); // Truncate for readability

    lines.push(`  '${task.id}': {`);
    lines.push(`    name: '${task.name.replace(/'/g, "\\'")}',`);
    lines.push(`    description: \`${escapedDesc}...\`,`);
    lines.push(`    department: '${task.department}',`);
    lines.push(`    frequency: '${task.frequency}',`);
    lines.push('  },');
  }

  lines.push('};');
  lines.push('');

  // Write the output file
  writeFileSync(OUTPUT_PATH, lines.join('\n'));
  console.log(`âœ… Generated ${OUTPUT_PATH}`);
  console.log(`   ${tasks.length} task templates`);
}

generateTaskTypes();
